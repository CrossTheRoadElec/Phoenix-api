def buildlinuxDesktop = project.hasProperty('buildlinuxDesktop') ? Boolean.parseBoolean(project.buildlinuxDesktop) : false
def buildfrc = project.hasProperty('buildfrc') ? Boolean.parseBoolean(project.buildfrc) : true
def buildarmGnueabihf = project.hasProperty('buildarmGnueabihf') ? Boolean.parseBoolean(project.buildarmGnueabihf) : false

def frcCompilerPrefix = project.hasProperty('frcCompilerPrefix') ? project.frcCompilerPrefix : 'arm-frc-linux-gnueabi-'
def frcCompilerArgs = project.hasProperty('frcCompilerArgs') ? project.frcCompilerArgs : ['-DSUPPORT_ROBORIO']
def toolChainPathfrc = project.hasProperty('toolChainPathfrc') ? project.toolChainPathfrc : null

def linuxDesktopCompilerPrefix = project.hasProperty('linuxDesktopCompilerPrefix') ? project.linuxDesktopCompilerPrefix : 'x86_64-linux-gnu-'
def linuxDesktopCompilerArgs = project.hasProperty('linuxDesktopCompilerArgs') ? project.linuxDesktopCompilerArgs : []
def toolChainPathlinuxDesktop = project.hasProperty('toolChainPathlinuxDesktop') ? project.toolChainPathlinuxDesktop : null

def armGnueabihfCompilerPrefix = project.hasProperty('armGnueabihfCompilerPrefix') ? project.armGnueabihfCompilerPrefix : 'arm-linux-gnueabihf-'
def armGnueabihfCompilerArgs = project.hasProperty('armGnueabihfCompilerArgs') ? project.armGnueabihfCompilerArgs : ['-mfloat-abi=hard']
def toolChainPatharmGnueabihf = project.hasProperty('toolChainPatharmGnueabihf') ? project.toolChainPatharmGnueabihf : null
model {
    platforms {
        frc {
            architecture 'arm'
            operatingSystem 'linux'
        }
        linuxDesktop {
            architecture 'x86'
            operatingSystem 'linux'
        }
        armGnueabihf {
            architecture 'arm'
            operatingSystem 'linux'
        }
    }
    toolChains {
        armGcc(Gcc) {
            if (toolChainPathfrc != null) path(toolChainPathfrc)
            target("frc") {
                // We use a custom-built cross compiler with the prefix arm-frc-linux-gnueabi-<util name>
                // If this ever changes, the prefix will need to be changed here
                cCompiler.executable = frcCompilerPrefix + cCompiler.executable
                cppCompiler.executable = frcCompilerPrefix + cppCompiler.executable
                linker.executable = frcCompilerPrefix + linker.executable
                assembler.executable = frcCompilerPrefix + assembler.executable
                // Gradle auto-adds the -m32 argument to the linker and compiler. Our compiler only supports
                // arm, and doesn't understand this flag, so it is removed from both
                cppCompiler.withArguments { args ->
		    		args << '-std=c++1y' << '-Wformat=2' << '-Wall' << '-Wextra' << '-Werror' << '-pedantic'
		    		args << '-fPIC' << '-rdynamic'
                    args << '-pthread'
                    args.remove('-m32')
                    frcCompilerArgs.each{
                        args << "${it}"
                    }
                }
                linker.withArguments { args ->
                    args << '-rdynamic' << '-pthread'
                    args.remove('-m32')
                    frcCompilerArgs.each{
                        args << "${it}"
                    }
                }
                staticLibArchiver.executable = frcCompilerPrefix + staticLibArchiver.executable
            }
            if (toolChainPathlinuxDesktop != null) path(toolChainPathlinuxDesktop)
            target("linuxDesktop") {
                // We use a custom-built cross compiler with the prefix arm-frc-linux-gnu-gnueabi-<util name>
                // If this ever changes, the prefix will need to be changed here
                cCompiler.executable = linuxDesktopCompilerPrefix + cCompiler.executable
                cppCompiler.executable = linuxDesktopCompilerPrefix + cppCompiler.executable
                linker.executable = linuxDesktopCompilerPrefix + linker.executable
                assembler.executable = linuxDesktopCompilerPrefix + assembler.executable
                // Gradle auto-adds the -m32 argument to the linker and compiler. Our compiler only supports
                // arm, and doesn't understand this flag, so it is removed from both
                cppCompiler.withArguments { args ->
		    		args << '-std=c++1y' << '-Wformat=2' << '-Wall' << '-Wextra' << '-Werror' << '-pedantic'
		    		args << '-fPIC' << '-rdynamic'
                    args << '-pthread'
                    args.remove('-m32')
                    linuxDesktopCompilerArgs.each{
                        args << "${it}"
                    }
                }
                linker.withArguments { args ->
                    args << '-rdynamic' << '-pthread'
                    args.remove('-m32')
                    linuxDesktopCompilerArgs.each{
                        args << "${it}"
                    }
                }
                staticLibArchiver.executable = linuxDesktopCompilerPrefix + staticLibArchiver.executable
            }
            if (toolChainPatharmGnueabihf != null) path(toolChainPatharmGnueabihf)
            target("armGnueabihf") {
                // We use a custom-built cross compiler with the prefix arm-frc-linux-gnu-gnueabi-<util name>
                // If this ever changes, the prefix will need to be changed here
                cCompiler.executable = armGnueabihfCompilerPrefix + cCompiler.executable
                cppCompiler.executable = armGnueabihfCompilerPrefix + cppCompiler.executable
                linker.executable = armGnueabihfCompilerPrefix + linker.executable
                assembler.executable = armGnueabihfCompilerPrefix + assembler.executable
                // Gradle auto-adds the -m32 argument to the linker and compiler. Our compiler only supports
                // arm, and doesn't understand this flag, so it is removed from both
                cppCompiler.withArguments { args ->
		    		args << '-std=c++1y' << '-Wformat=2' << '-Wall' << '-Wextra' << '-Werror' << '-pedantic'
		    		args << '-fPIC' << '-rdynamic'
                    args << '-pthread'
                    args.remove('-m32')
                    armGnueabihfCompilerArgs.each{
                        args << "${it}"
                    }
                }
                linker.withArguments { args ->
                    args << '-rdynamic' << '-pthread'
                    args.remove('-m32')
                    armGnueabihfCompilerArgs.each{
                        args << "${it}"
                    }
                }
                staticLibArchiver.executable = armGnueabihfCompilerPrefix + staticLibArchiver.executable
            }
        }
    }
    binaries {
       withType(SharedLibraryBinarySpec) {
               cppCompiler.define "CCI_BIN_SHARED"
       }
    }		
	binaries {
		withType(StaticLibraryBinarySpec) {
			cppCompiler.define "CCI_BIN_STATIC"
		}
	}
}
ext.binToolslinuxDesktop = { tool ->
    if (toolChainPathlinuxDesktop != null) return "${toolChainPathlinuxDesktop}/${linuxDesktopCompilerPrefix}${tool}"
    return "${linuxDesktopCompilerPrefix}${tool}"
}
ext.binToolsfrc = { tool ->
    if (toolChainPathfrc != null) return "${toolChainPathfrc}/${frcCompilerPrefix}${tool}"
    return "${frcCompilerPrefix}${tool}"
}
ext.binToolsarmGnueabihf = { tool ->
    if (toolChainPatharmGnueabihf != null) return "${toolChainPatharmGnueabihf}/${armGnueabihfCompilerPrefix}${tool}"
    return "${armGnueabihfCompilerPrefix}${tool}"
}
ext.setupReleaseDefines = { cppCompiler, linker ->
    cppCompiler.args '-O2', '-g'
}

ext.setupDebugDefines = { cppCompiler, linker ->
    cppCompiler.args '-g', '-O0'
}

// Used only on Windows.
ext.setupDef = { linker, deffile -> }

ext.debugStripSetup = {
    if (!project.hasProperty('debug')) {
        project.tasks.whenObjectAdded { task ->
            if (task.name.contains('link') && task.name.contains('SharedLibrary')) {
                def library = task.outputFile.absolutePath
                def debugLibrary = task.outputFile.absolutePath + ".debug"
                task.doLast {
                    if(task.targetPlatform.name == "linuxDesktop") {
                        //exec { commandLine binToolslinuxDesktop('objcopy'), '--only-keep-debug', library, debugLibrary }
                        //exec { commandLine binToolslinuxDesktop('strip'), '-g', library }
                        //exec { commandLine binToolslinuxDesktop('objcopy'), "--add-gnu-debuglink=$debugLibrary", library }
                    }
                    else if(task.targetPlatform.name == "frc") {
                        //exec { commandLine binToolsfrc('objcopy'), '--only-keep-debug', library, debugLibrary }
                        //exec { commandLine binToolsfrc('strip'), '-g', library }
                        //exec { commandLine binToolsfrc('objcopy'), "--add-gnu-debuglink=$debugLibrary", library }
                    }
                    else if(task.targetPlatform.name == "armGnueabihf") {
                        //exec { commandLine binToolsarmGnueabihf('objcopy'), '--only-keep-debug', library, debugLibrary }
                        //exec { commandLine binToolsarmGnueabihf('strip'), '-g', library }
                        //exec { commandLine binToolsarmGnueabihf('objcopy'), "--add-gnu-debuglink=$debugLibrary", library }
                    }
                    
                }
            }
        }
    }
}

ext.checkNativeSymbols = { getSymbolFunc ->
    project.tasks.whenObjectAdded { task ->
        if (task.name.contains('link') && task.name.contains('SharedLibrary')) {
            
            def library = task.outputFile.absolutePath
            task.doLast {
                def nmOutput = new ByteArrayOutputStream()
                exec { 
                    if(task.targetPlatform.name == "linuxDesktop") {
                        commandLine binToolslinuxDesktop('nm'), library
                        standardOutput nmOutput
                    }
                    else if(task.targetPlatform.name == "frc") {
                        commandLine binToolsfrc('nm'), library
                        standardOutput nmOutput
                    }
                    else if(task.targetPlatform.name == "armGnueabihf") {
                        commandLine binToolsarmGnueabihf('nm'), library
                        standardOutput nmOutput
                    }
                }
                // Remove '\r' so we can check for full string contents
                String nmSymbols = nmOutput.toString().replace('\r', '')

                def symbolList = getSymbolFunc()
                symbolList.each {
                    //Add \n so we can check for the exact symbol
                    def found = nmSymbols.contains(it + '\n')
                    if (!found) {
                        throw new GradleException("Found a definition that does not have a matching symbol ${it}")
                    }
                }
            }
        }
    }
}
